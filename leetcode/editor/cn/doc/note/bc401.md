---
layout: post
title:  "BC401: Notes"
date:   2019-04-25 08:45:00 +0100
categories: jekyll update
---
This blog consists of main points or important notes from BC401.
The notes are divided according to Units.

## Unit 2:
-----------------
* **Attributes**

    * Instance Attributes: `DATA`
    * Static Attributes: `CLASS-DATA`

-------------------------------------------------

* **Methods**   

* Instance Method `METHODS` Syntax

Syntax for calling instance methods when multiple importing parameters.

{% highlight javascript %}
    ref->method_name(  iv_name = 'abc' iv_type = 'new' ).
{% endhighlight %}

Syntax for calling instance methods when only one importing parameter.

{% highlight javascript %}
    ref->method_name(  'abc' ).
{% endhighlight %}

* Static Method `CLASS-METHODS` Syntax

Syntax for calling static methods when multiple importing parameters.

{% highlight javascript %}
    class_name=>method_name(  iv_name = 'abc' iv_type = 'new' ).
{% endhighlight %}

Syntax for calling static methods when only one importing parameter.

{% highlight javascript %}
    class_name=>method_name(  'abc' ).
{% endhighlight %}

Syntax for calling static methods.

{% highlight javascript %}
    class_name=>method_name( ).
{% endhighlight %}

* **Functional Method Calls**
    * Precisely one RETURNING parameter.
    * RETURNING parameters must always be passed by value and not by reference.

Syntax for defining functional methods.

{% highlight javascript %}
    METHODS func_methods_name IMPORTING iv_name TYPE string
                                        iv_type TYPE string
                              RETURNING VALUE(rv_result) TYPE i. 
{% endhighlight %}

Syntax for calling functional methods.

{% highlight javascript %}
    result = ref->func_method_name( iv_name = 'abc' iv_type = 'new' ).
{% endhighlight %}

{% highlight javascript %}
    result = class_name=>func_method_name( iv_name = 'abc' iv_type = 'new' ).
{% endhighlight %}

-------------------------------------------------------

* **Object Creation**   

Syntax for creating objects
Old way:
{% highlight javascript %}
    DATA go_vehicle1 TYPE REF TO lcl_vehicle.
    CREATE OBJECT go_vehicle.
{% endhighlight %}

New way:
{% highlight javascript %}
    DATA(go_vehicle1) = NEW lcl_vehicle( ).
{% endhighlight %}

* **To check Object Reference is null or not**

Check if the object references (eg: go_obj) contains the null reference or does not point to any object using: `IS BOUND` or `IS INITIAL`
{% highlight javascript %}
    IF go_obj IS INITIAL.
        <<code>>
    ENDIF.
{% endhighlight %}

* **Multiple Instances**

    * To hold multiple objects from the same class, an internal table with one column that contains the object references for the class can be used.
    * To maintain the objects in the table, use `APPEND`, `READ` or `LOOP`.
{% highlight javascript %}
DATA go_vehicle TYPE REF TO lcl_vehicle.
DATA gt_vehicles TYPE TABLE OF REF TO lcl_vehicle.

go_vehicle = NEW lcl_vehicle( ).
APEEND go_vehicle TO gt_vehicles.
{% endhighlight %}

--------------------------------------------------------------------

* **Instance Constructor**
    * Only one instance constructor is allowed in a class.
    * Must be defined in public section.
    * Signature can only include importing parameters and exceptions.
    * When an exception is reaised in the contstructor no instances are created and no main memory space is occupied.
    * Except for one unique case, constructor cannot be called explicitly.
    * In which situations is constructor necessary?
        * To allocate resources.
        * To initialize attributes.
        * To modify static attributes.
        * To inform other objects about object creation.  

Syntax constructor definition

{% highlight javascript %}
CLASS lcl_vehicle DEFINITION.
    <<code>>
    METHODS constructor IMPORTING iv_name TYPE string
                                  iv_type TYPE string
                        RAISING exception_class.
    <<code>>
ENDCLASS.
{% endhighlight %}

Syntax constructor call

{% highlight javascript %}
    DATA(lo_vehicle) = NEW lcl_vehicle( iv_name = 'abc' iv_type = 'new' ).
{% endhighlight %}

---------------------------------------------------------------------------

* **Static Constructor**
    * Executed only once per program.
    * Called automatically by the system before the class is first accessed and before the first execution of following actions:
        * When an instance of the class is created.
        * When a static attribute of the class is accessed.
        * When a static method of the class is called.
        * When an event handler method for an event in the class is being registered.
        * Static constructor of superclass is executed when the superclass or one of its subclass is accessed for the first time.
    * Only one static constructor is allowed in a class.
    * Must be defined in the public section.
    * Does not have any parameters or exceptions.
    * Cannot be called explicitly.

Syntax static constructor definition

{% highlight javascript %}
CLASS lcl_vehicle DEFINITION.
    <<code>>
    METHODS class_constructor.
    <<code>>
ENDCLASS.
{% endhighlight %}

------------------------------------------------------------------------------------

* **Self Reference**
    * Used to address an object itself using predefined reference variable `ME` within its instance methods.
    * `ME->` must be used to distinguish between local data objects and instance attributes with same names.

-------------------------------------------------------------------------------------

* **New ABAP SQL SELECT**

Old way

{% highlight javascript %}
    DATA ls_planetype Type saplane.
    SELECT SINGLE * FROM saplane INTO ls_planetype WHERE planetype = iv_planetype.
{% endhighlight %}

New way

{% highlight javascript %}
    SELECT SINGLE weight, tankcap FROM saplane WHERE planetype = @iv_planetype INTO @DATA(ls_plane).
{% endhighlight %}

* **Read an internal table and transport data**

{% highlight javascript %}
    READ TABLE gt_planetypes INTO DATA(ls_planetype) WITH TABLE KEY planetype = iv_planetype
                                                          TRANSPORTING weight tankcap.
{% endhighlight %}

--------------------------------------------------------------------------------

## Unit 3:
-----------------

* **Inheritance**
    * Is-a relationship. *eg: truck is a specific vehicle. (subclass is a superclass)*
    * There is no multiple inheritance in ABAP Objects. However, interfaces can be used to simulate multiple inheritance.

Syntax implementation of Inheritance

{% highlight javascript %}
    CLASS lcl_vehicle DEFINITION.
        PUBLIC SECTION.
            METHODS set_type IMPORTING iv_make TYPE string.
        PRIVATE SECTION.
            DATA mv_make TYPE string.
        <<code>>
    ENDCLASS.

    CLASS lcl_truck DEFINITION INHERTING FROM lcl_vehicle.
        PUBLIC SECTION.
            METHODS get_cargo RETURNING VALUE(rv_cargo) TYPE s_plan_car.
        PRIVATE SECTION.
            DATA mv_cargo TYPE s_plan_car.
        <<code>>
    ENDCLASS.
{% endhighlight %}

* **REDEFINITION**
    * Implementation of an inherited method is changed for the subclass without changing the signature.
    * Redefinition is possible in same visibility. *eg: if superclass has method in public section, then in subclass this method has to redefined in public section. It cannot be private.*
    * As the signature remains the same, there is no need to define the method parameters and exceptions again.
    * Use `super->superclass_method( )` to call original methods and `super->superclass_attribute` to access components of the superclass in redefined implementation.
    * Static methods cannot be redefined.
    * Redefined methods can be renamed in the UML diagram within subclass.

{% highlight javascript %}
    CLASS lcl_vehicle DEFINITION.
        <<code>>
        PUBLIC SECTION.
            METHODS display_attributes.
        <<code>>
    ENDCLASS.

    CLASS lcl_truck DEFINITION INHERTING FROM lcl_vehicle.
        <<code>>
        PUBLIC SECTION.
            METHODS display_attributes REDEFINITION.
        <<code>>
    ENDCLASS.

    CLASS lcl_truck IMPLEMENTATION.
        <<code>>
        METHOD display_attributes.
            super->display_attributes( ).
        ENDMETHOD.
        <<code>>
    ENDCLASS.
{% endhighlight %} 

* **Subclass Constructor**
    * Any class can define its own cosntructor that is fully independent from definition of constructor in superclass.
    * A subclass can even define a constructor if there is no constructor in the superclass.
    * But while implementing subclass constructor it is mandatory to call superclass constructor.
    * Because of this enforced call of the super class constructor, the subclass constructor generally adds parameters to the signature of the superclass constructor rather than completely changing it.
    * If a subclass has not changed its instance constructor, then the constructor is adopted from the superclass. The implementation is also inherited from the superclass.
    * Subclass can always have static constructor irrespective of superclass.
    * If subclass and superclass both have static constructor, then both constructors are executed when we access the subclass for the first time.
    * If access to the superclass and subclass constructor occurs at the same time, the superclass static constructor will execute first, imeediately followed by the subclass static constructor.

Example of instance constructor in subclass

{% highlight javascript %}
    CLASS lcl_vehicle DEFINITION.
        <<code>>
        PUBLIC SECTION.
            METHODS constructor IMPORTING iv_make_v TYPE string.
        <<code>>
    ENDCLASS.

    CLASS lcl_vehicle IMPLEMENTATION.
        <<code>>
        METHOD constructor.
            mv_make = iv_make_v.
        ENDMETHOD.
        <<code>>
    ENDCLASS.


    CLASS lcl_truck DEFINITION INHERTING FROM lcl_vehicle.
        <<code>>
        PUBLIC SECTION.
            METHODS constructor IMPORTING iv_make_t TYPE string
                                          iv_cargo_t TYPE s_plan_car.
        <<code>>
    ENDCLASS.

    CLASS lcl_truck IMPLEMENTATION.
        <<code>>
        METHOD constructor.
            super->constructor( iv_make_v = iv_make_t ).
            mv_cargo = iv_cargo_t.
        ENDMETHOD.
        <<code>>
    ENDCLASS.
{% endhighlight %}

* **Method Overloading**
    * Method overloading means, a method can have several definitions with different signatures and different implementations.
    * The concept of overloading is not supported in ABAP Objects.
    * Workaround: One signature with different sets of optional parameters.

* **Upcasts *(widening cast)***
    * When you assign a subclass instance to a superclass reference.
    * In this case only the methods and attributes from the subclass instance which are inherited from superclass can be addressed.
    * That is subclass specific methods or attributes cannot be addressed using this reference.
    * Incase of the redefined methods, the implementation depends on which object the superclass reference refers to. The dynamic type of the reference variable is used to search for the implementation of the method.
    * As the target variable (typed to superclass) can accept more dynamic types in comparison to the source variable (subclass), this assignment is called the widening cast.

{% highlight javascript %}
    <<code>>
    *Vehicle is superclass and Truck is its subclass
    
    DATA go_vehicle TYPE REF TO lcl_vehicle.
    DATA(go_truck) = NEW lcl_truck( ).

    *Up-cast (widening cast)
    go_vehicle = go_truck.

    <<code>>
{% endhighlight %}

* **Static Types**
    * Defined using `TYPE REF TO`.
    * Remains same throughout.
    * Defines which attributes and methods can be addressed.

* **Dynamic Types**
    * Determined by the assignment.
    * Can change during the program run.
    * Defines which implementations are carried out for the inherited methods.

* **Polymorphism**
    * When objects from different classes react differentyl to the same method call.
    * Polymorphism can be used to write programs which are highly generic.
    * Upcasts is generally used to achieve this.
    * eg: lcl_rental class which contains the mt_vehicles internal table typed to lcl_vehicle and method add_vehicle importing io_vehicle typed to lcl_vehicle.
    * This method will add the passed object to the mt_vehicles table by upcasting it. Hence it will provide generic access.
    * When the display attributes methods is called, the implementation now depends on which object the superclass reference lo_vehicle refers to. 

{% highlight javascript %}
    CLASS lcl_rental DEFINITION.
        PUBLIC SECTION.
            METHODS add_vehicle IMPORTING io_vehicle TYPE REF TO lcl_vehicle.
            METHODS display_attributes.
        
        PROTECTED SECTION.
            DATA mt_vehicles TYPE TABLE OF REF TO lcl_vehicle.
    ENDCLASS.

    CLASS lcl_rental IMPLEMENTATION.
        METHOD add_vehicle.
            APPEND io_vehicle TO mt_vehicles.
        ENDMETHOD.

        METHOD display_attributes.
            LOOP AT mt_vehicles INTO DATA(lo_vehicle).
                lo_vehicle->display_attributes( ).
            ENDLOOP.
        ENDMETHOD.
    ENDCLASS.
{% endhighlight %}

* **Downcasts *(narrowing cast)***
    * When you assign Superclass reference (go_vehicle) which is pointing to subclass instance (go_truck), to a reference variable of subclass (go_truck2).
    * To assign subclass reference to a superclass reference, you must use the downcast assignment operator `MOVE .. ? TO ..` or `?=`.
    * After assigning this type of reference back to a subclass reference, you can access all the components and not only the inherited components (upcasts allow only access to the inherited components but redefined methods from subclass).
    * As the target variable can accept the less dynamic types after the assignment. This assignment is also called narrowing cast.
    * Use of downcasts:
        * Downcasts are used when you need to address specific components of instances and keep the references of these components in variables that are typed on the superclass.
        * You need to surround downcast assignment with `TRY-ENDTRY and CATCH` statement to identify the exception of error class `CX_SY_MOVE_CAST_ERROR`.

{% highlight javascript %}
    <<code>>
    *Vehicle is superclass and Truck is its subclass
    
    DATA go_vehicle TYPE REF TO lcl_vehicle.
    DATA go_truck2 YPE REF TO lcl_truck.

    DATA(go_truck) = NEW lcl_truck( ).

    *Up-cast (widening cast)
    go_vehicle = go_truck.

    *Down-cast (narrowing cast) old way
    TRY.
        go_truck2 ?= go_vehicle.
        CATCH cx_sy_move_cast_error.
    ENDTRY.

    *Down-cast (narrowing cast) new way
    TRY.
        DATA(go_truck3) = CAST lcl_truck(go_vehicle).
        CATCH cx_sy_move_cast_error.
    ENDTRY.
    <<code>>
{% endhighlight %}

* **Misuse of Inheritance**
    * The need for another attribute for a class is incorrectly answered with specialization.
        * eg: A superclass called CAR, contains the subclasses RED CAR, BLUE CAR and so on. 
        * The statement that a `RED CAR is a specific CAR` is correct at first glance, but there are no CARS without a color.
        * Therefore every car needs the attribute color which must be defined in the superclass rather than creating the subclass according to the color.
    * Using inheritance only because some required functions are found in a superclass is also not appropriate.
        * eg: The square class inherits from the rectangle class. 
        * If you try to define methods for the rectangle that change the width and height separately, these methods will not make sense when applied to the square.
        * Even if the methods are redefined to make the lengths of sides uniform the semantics will be different.

------------------------------------------------------------------------------------

## Unit 4:
-----------------

* **Interface**
    * Can be seen as superclasses that cannot be instantiated.
    * Do not contain any implementations.
    * Contains only public components.
    * Multiple inheritances can be simulated using interfaces.

{% highlight javascript %}
    * Definition of the interface
    INTERFACE lif_partner.
        METHODS display_partner.
    ENDINTERFACE.

    * Implementation in "server" class
    * Note: Interfaces can only be implemented in the public section as below
    CLASS lcl_rental DEFINITION.
        PUBLIC SECTION.
            INTERFACES lif_partner.
    ENDCLASS.

    CLASS lcl_rental IMPLEMENTATION.
        METHOD lif_partner~display_partner.
            <<code>>
        ENDMETHOD.
    ENDCLASS
{% endhighlight %}

* **Use-case example for Interface**
    * You want to allow multiple classes to implement a service in different ways, but using the same method names and a uniform signature.
    * With regular inheritance, you would define such a method in the shared superclass.
    * Howerver, if you cannot model a superclass for inheritance suitably, you need to define an interface and then define the method in the interface.
    * Therefore, you can compare this case with generalization relationship with a superclass.

* **Polymorphism with Interfaces**
    * An interface reference can only refer to instances of classes that have implemented the interface because interfaces themselves cannot be instantiated.
    * Use upcast to copy a reference (of the class that has implemented the interface) to the interface reference variable to perform polymorphism with interfaces.
    * From this interface reference, only the components from the interface can be accessed.
    * Prefixing of the interface name and the interface resolution operator is ommited.
    * It is not possible to access the specific components of the instance go_rental from the lcl_rental class using the `go_partner` reference variable.
    * You can access only the `display_partner( )` and `check_availability( )` methods of the lif_partner.
    * As the target reference can accept more dynamic types after the assignment, than it could before. Hence the term widening cast is also suitable.
    * The dynamic type of reference variable is used to search for the implemntation of a method.
    * In the above example `go_partner->display_partner( )` uses the class of the instance to which the `go_partner` actually points to in order to search for the implementation for `display_partner( )`.
    * Use of such Up-casts is for providing more generic access.


{% highlight javascript %}
    DATA go_rental TYPE REF TO lcl_rental.
    DATA go_partner TYPE REF TO lif_partner.

    go_rental = NEW #( ).
    
    * Up-cast (Note go_rental implements the interface lif_partner)
    go_partner = go_rental.
{% endhighlight %}

* **Downcasts with interface**
    * To assign an interface reference to a class reference where the class has implemented the interface, you must use the down-cast operator `MOVE ... ?TO ...` or its short form `?=`.
    * As a rule implementing class contains more components than the interface.
    * Interface reference variables can contain refernces to instances of the implementing class at runtime.
    * After assigning this type of reference back to a reference to the implementing class, clients are no longer limited to interface components.
    * This type of reference variable assignment is described as down-casting.
    * A typical area of use of down-cast assignments is when specific components of instances need to be addressed whose references are kept in variables that are type on the interface.

{% highlight javascript %}
    <<code>>
    *Carrier implments the interface and holds other class objects in mt_partners table
    *Old way
    DATA go_carrier TYPE REF TO lcl_carrier.
    DATA lo_partner YPE REF TO lif_partner.

    LOOP AT mt_partners INTO lo_partner.
        TRY.
            lo_carrier ?= lo_partner.
          CATCH cx_sy_move_cast_error.
            * React on that cast error
        ENDTRYP.

    ENDLOOP.

    *New Way.
    LOOP AT mt_partners INTO DATA(lo_partner).
        TRY.
          DATA(lo_carrier) = CAST lcl_carrier( lo_partner ).
          CATCH cx_sy_move_cast_error.
          * React on that cast error
        ENDTRY.
    ENDLOOP.
    <<code>>
{% endhighlight %}

* **Submodel Integration Using Interfaces**
    * The steps to integrate a submodel using interfaces are as follows:
        * Create classes of the submodel (lcl_airplane, lcl_passenger_plane, lcl_cargo_plane).
        * Include given interface into server class (lcl_carrier in our example) of submodel. (Protocal is defined by client).
        * Create instances of server class and refer to them with interface reference (lif_partner in our example).

* **Compund Interface and Component Interface**
    * In ABAP Objects, interfaces like regular superclasses can include other interfaces.
    * eg: `lif_lodging` inherits from `lif_partner` (in terms of inheritance lif_partner interface is superclass and lif_lodging is subclass).
    * The including interface (`lif_lodging`) is a specialization of the included interface (`lif_parnter`).
    * The including interface is known as compound interface (`lif_lodging`) and the included interface (`lif_partner`) is component interface.
    * An interface that does not contain other interfaces in itself is known as elementary interface.
    
{% highlight javascript %}
    * Component Interface
    INTERFACE lif_partner. 
        METHODS display_partner.
    ENDINTERFACE.

    * Compound Interface
    INTERFACE lif_logding.
        INTERFACES lif_partner.
        METHODS book_room.
    ENDINTERFACE.

    CLASS lcl_hotel DEFINITION.
        PUBLIC SECTION.
            INTERFACES lif_lodging.
    ENDCLASS.

    CLASS lcl_hotel IMPLEMENTATION.
        
        METHOD lif_partner~display_partner.
            <<code>>
        ENDMETHOD
        
        METHOD lif_lodging~book_room.
            <<code>>
        ENDMETHOD.

    ENDCLASS.
{% endhighlight %}

* **Correct use of Interfaces**
    * If there is no suitable way to link classes in terms of inheritance, creating generalization/specialization relationships using interfaces can have following advantages:
        * Separation of the protocol interface - often defined by user and the service.
        * Safe, generic method of access.
        * Ability to simulate multiple inheritance.
    * This means that entire software component can be extended very easily.
    * Interfaces are used to describe protocols for using components without connecting any implementation.
    * An intermediate layer is introduced to protect the client from the explicit server, thereby making the client independent.
    * Interfaces enable different classes to be handled uniformly, provided those classes have implemented the interfaces.
    * As with inheritance, you can also perform polymorphism using interfaces reference variables.

 ------------------------------------------------------------------------------------

## Unit 5:
-----------------

* **Event-Controlled Method Calls**
    * Inaddition to attributes and methods, classes and their instances can also contain events.
    * Instance events can be triggered by the instances of the class. Instance events are defined using `EVENTS`.
    * Static events can be triggered by the class itself. Static events are defined using `CLASS-EVENTS`.
    * Events can also be defined as the interface components.
    * A class or instance can trigger an event at runtime using the `RAISE EVENT` statement.
    * Both instance events and static events can be triggered in instance methods.
    * But only static events can be triggered in the static methods.
    * Instance events and static methods can be defined within a class to handle events. To do so, you must specify the event using the `FOR EVENT` statement, and the class or interface in which the event was defined using the `OF` statement.
    * The predefined importing parameter `SENDER` can be used to place a reference to the event-trigger object into the handler method.

{% highlight javascript %}
    * Event Triggering
    CLASS lcl_vehicle DEFINITION.
        PUBLIC SECTION.
            METHODS constructor IMPORTING iv_name TYPE string.
            " 1) Define an event in a class."
            EVENTS vehicle_created.
        <<code>>
    ENDCLASS.

    CLASS lcl_vehicle IMPLEMENTATION.
        METHOD constructor.
            <<code>>
            " 2) Trigger the event in a method of this class. " 
            RAISE EVENT vehicle_created.
        ENDMETHOD.
    ENDCLASS.

    * Event Handling
    CLASS lcl_rental DEFINITION.
        METHODS constructor.
        " 3) Define the handler method in the same or another class. "
        METHODS on_vehicle_created FOR EVENT vehicle_created OF lcl_vehicle 
                                                             IMPORTING sender.
    ENDMETHOD.

    CLASS lcl_rental IMPLEMENTATION.
        " 3) Implement the hanlder method. "
        METHOD on_vehicle_created.
            <<code>>
        ENDMETHOD.

        METHOD constructor.
        " 4) Register handler object or handler class to events at runtime.
        SET HANDLER ME->on_vehicle_created FOR ALL instances.
        ENDMETHOD.
    ENDCLASS
{% endhighlight %}

* **Procedure to trigger and handle events**
    1. Define an event in a class. The syntax for this is `EVENTS eventname`, `CLASS-EVENTS eventname`.
    2. Trigger the event in a method of this class. The syntax for this is `RAISE EVENT eventname`.
    3. Define and implement the handler method in the same or another class. The sytax for this is `[CLASS-]METHODS ... FOR EVENT ... OF`.
    4. Register handler object or handler class to events at runtime. The syntax for this is `SET HANDLER`.

* **Event Handler Registration**
    * The definition of the handler method only specifies how and to which event of which class the method will react.
    * At runtime, it needs to be determined which possible reactions will actually take place and when each of these reactions will happen.
    * When triggering instance events, you also have to specify which event the reaction will trigger.
    * If instance methods are set to carry out the reaction, you also have to specify which instances will perform the reaction.
    * These specifications are collectively known as registration.
    * Registration is always carried out using the trigger.
    * When the event is triggered, the runtime uses the registrations of the trigger to determine which event hanlder methods needs to be called.
    * Events are registered using the `SET HANDLER` statement. Registration is only active during program runtime.
    * With instance events, `FOR` is followed by the reference to the object that triggers the event.
    * The addition `ACTIVATION 'X'` is optional during registration. 
    * To undo the registration, use `ACTIVATION ''`.
    * You can register several methods with one `SET HANDLER` statement.
    `SET HANDLER ref_handler_1->on_eventname_1 .... ref_handler_n->on_eventname_n FOR`
    * If several methods were registered to one event, the sequence in which the event handler methods are called is not defined.
    * With the addition `ALL INSTANCES` an event handler can be registered for all instances of the class that defines the instance event. This is the only way to register handlers for instances that have not yet been created.

{% highlight javascript %}
    SET HANDLER ref_handler->on_eventname
                [ FOR ref_sender | FOR ALL INSTANCES]
                [ ACTIVATION flag ].
{% endhighlight %}

* **Event Handler Registration/Deregistration tables**
    * Every object or class that defines events has an internal table known as the ahndler table.
    * All handler methods that are registered to the various events are listed within the handler table.
    * For instance methods, the handler table also contains references to the registered objects.

* **Events handler and handler method visibility**
    * The visibility of an event defines where the event can be handled.
    * The visibility of an event handler defines where the handler method can be registered.
    * Event-handler methods can only have the same or more restricted visibility than the events they refer to.

------------------------------------------------------------------------------------

## Unit 6:
-----------------

* **Definition of global classes**
    * Global classes or global interfaces are individual repository objects with all the standard ABAP workbench features such as active integration, versioning, transport system.
    * The namespace convention, for example Y*, Z* or a special customer namespace is the same as that name used for the namespace of other repository objects.
    * Class Builder Testing Environment (Only available in ABAP workbench):
        * You can test active global classes by choosing menu path `Class -> Run -> In Test Environament`, choosing the corresponding application toolbar button or press `F8`.
        * Static attributes and static methods are directly accessible in the test environment.
        * Instance attributes and instance methods are accessible after instance creation only. You can create an instance using the `Create Instance` button.
        * The system only lists the public components. Methods can be tested using the `Execute Method` button.

------------------------------------------------------------------------------------

## Unit 9:
-----------------

* **Class-Based Exceptions**
    * This is a new cocept introduced that exists in parallel to the existing concept based on `sy-subrc`.
    * Exeptions and exception handling are based on classes.
    * In this new concept, an exception is represented by an exception object. This exception object is an instance of an exception class.
    * The attribute values of the exception object contain information about the respective error situation.
    * Raising a class-based exception means instantiating an exception class and setting the attributes.
    * Handling a class-based exception invovles evaluating the exception object and its attribute values.
    * Class-based exceptions are raised either by the `RAISE EXCEPTION` statement or by the runtime environment.
    * These exceptions are caught and handled using `TRY ... CATCH ... ENDTRY` structure.

* **Hierarchy of Exception Classes**
    * The names of global exception classes always start with `<namespace>CX_`.
    * Global exception classes that the runtime environment uses start with `CX_SY_`.
    * It is recommended to start the names of local exception classes with `LCX_`.
    * All exception classes are derived from one exception class `CX_ROOT`.
    * Therefore, you can generically access any exception object through a reference variable, `REF TO CX_ROOT`.
    * But a new exception class is not allowed to inherit directly from CX_ROOT.
    * Derive any new exception class directly or indirectly from one of the subclass of `CX_ROOT` - `CX_NO_CHECK`, `CX_DYNAMIC_CHECK` or `CX_STATIC_CHECK`.
    * All exception classes are subdivided into three groups. Depending on the group to which a given exception belongs, the exception is treated differently by syntax check and runtime environment.
    * The default group is `CX_STATIC_CHECK`, which ensures the maximum syntax check and program stability.
    * Use other groups only in special cases.
    * The `get_source_position( )` method returns the name of the main program or the include program and also the line number in the source code where the exception occurs.
    * The `get_text( )` method returns an exception text in the form of a string. This method is not defined in the `CX_ROOT` directly but in the interface `IF_MESSAGE`, which is implemented by CX_ROOT.

* **Class-Based Exception Handling**
    * You can handle an exception of the statement that raised it is enclosed inside a `TRY-ENDTRY` control structure.
    * You can handle the exception using the `CATCH` statement in the `TRY-ENDTRY` structure.
    * The `TRY` block contains the statements for which the excepitons needs to be handled.
    * A `CATCH` block contains the exception handler, which is executed if a specified exception has occurred in the associated `TRY` block.
    * `TRY-ENDTRY` structures can be nested to any depth.
    * You can specify any number of exceptions in the `CATCH` statement.
    * If the system doesnot find a matching `CATCH` statement, it gradually searches outwards in the surrounding `TRY-ENDTRY` structures. If no handler can be found within the same procedure, the system tries to propagate the exception to the calling program. 
    * If a `TRY-ENDTRY` structure contains a `CLEANUP` block, this block is executed when the `TRY-ENDTRY` structure is exited because the system cannot find a handler within the `TRY-ENDTRY` structure itself, but instead in a surrouding `TRY-ENDTRY` structure on in a calling program.

{% highlight javascript %}
    TRY.
        <<code>>
        "Statements for which exceptions are to be handled"

        CATCH cx_... cx_... cx_... [INTO gx_exc1].
            <<code>>
            "Excecuted if specified exception classes or their subclasses are raised"
        
        CATCH cx_... [INTO gx_exc1].
            <<code>>
            "Executed if specified exception classes or their subclasses are raised"
        
        CLEANUP.
            <<code>>
            "Executed if there is no local exception handler (usually if exception is to be propogated)"
    
    ENDTRY.
{% endhighlight %}

* **Example for Handling Predefined Exceptions**
    * To analyze the exception object in an exception handler, use the `CATCH` statement in the form `CATCH ... INTO ...`.
    * You have to specify a suitably typed object reference after the optional addition `INTO`.
    * The reference can be a reference either to the exception class itself or to any of its superclasses.
    * Just before the system exceutes the `CATCH` block, the system fills the reference variable so that it points to the exception object describing the present error situation.
    * In the examplee below, the reference variable is typed as `REF TO CX_ROOT`, which restricts the access to those components defined in `CX_ROOT`.
    * To access the more-specific components of the exception object, you need a more-specific type reference variable type.
    * You can also use the superclass `CX_SY_ARITHMETIC_ERROR` and the super-superclass `CX_DYNAMIC_CHECK` to access the specific components of the exception object.

{% highlight javascript %}
    PARAMETERS: pa_int1 TYPE i,
                pa_int2 TYPE i.
    
    DATA: gv_result TYPE i,
          gv_text TYPE string,
          gx_exc TYPE REF TO cx_root.
    
    TRY.
        gv_result = pa_int1 * pa_int2.
        WRITE gv_result.
        CATCH cx_sy_arithmetic_overflow INTO gx_exc.
            gv_text = gx_exc->get_text( ).
            MESSAGE gv_text type 'I'.
    ENDTRY.
{% endhighlight %}

------------------------------------------------------------------------------------

## Unit 11:
-----------------

* **Abstract Classes**
    * Abstract class contains both definition and implementation but cannot be instantiated.
    * To create an abstract class add `ABSTRACT` athe the end while definining class.
    * Super classes are a typical use for abstract classes, as they are not to be instantiated themselves but their subclasses are.
    * In an abstract class, you can define abstract methods.
    * This means that the abstract method cannot be implemented in that class. Instead, it is implemented in a subclass of the class.
    * If the subclass of that class is not abstract, the abstract methods must be redefined and implemented in the subclass for the first time.
    * References to such abstract classes can be used for polymorphic access to subclass instances.
    * Static methods cannot be abstract because they cannot be redefined.

{% highlight javascript %}
    CLASS lcl_demo DEFINITION ABSTRACT.
        "Class cannot be instantiated"
        <<code>>
    ENDCLASS.

    CLASS lcl_demo_1 DEFINITION ABSTRACT.
        <<code>>
        "Method is not implemented in this class"
        METHODS example ABSTRACT.
        <<code>>
    ENDCLASS.
{% endhighlight %}

* **Final Classes**
    * Prevent a class from being inherited by using the `FINAL` addition with the class statement.
    * A method can be prevented from being redefined by using the `FINAL` addition while defining.
    * This all methods of a final class are implicitly final. The final additions need not be repeated for methods.
    * Classes that are abstract and final should only contain static components.

{% highlight javascript %}
    CLASS lcl_demo DEFINITION FINAL [INHERITING FROM ... ].
        "Other classes cannot inherit from this one"
        <<code>>
    ENDCLASS.

    CLASS lcl_demo DEFINITION.
        <<code>>
        "Method cannot be redefined"
        METHODS example FIANL.
        <<code>>
    ENDCLASS.
{% endhighlight %}

* **Navigation Methods and Chain Method Calls**
    * An association means that at runtime, an instance of one class stores references to objects of another class.
    * Class that have other classes associated with them often come with methods that returnone of the stored references to the caller.
    * Such methods are often called navigation methods, as they can be used to navigate from one object to another.
    * In the example, the `LCL_VEHICLE` class is associated with the `LCL_RENTAL` class.
    * Class `LCL_RENTAL` provides the navigation method `get_vehicle( )`.
    * Often the purpose of navigating from one object to another is to access a single method of this other object.
    * We can chain method calls, that is, we can directly call a method of the object that the navigation method returns.
    * This technique is not restricted to the chaining of two methods.
    * In more complicated object models, it is possible to chain any number of methods.

{% highlight javascript %}
    "lcl_rental holds the references of lcl_vehicles in mt_vehicles"
    
    "Old way"
    Data: go_rental TYPE REF TO lcl_rental,
          go_vehicle TYPE REF TO lcl_vehicle.

    go_vehicle = go_rental->get_vehicle( ).
    go_vehicle->display_attributes( ).

    "New way/alternate way"
    DATA go_rental TYPE REF TO lcl_rental.
    go_rental->get_vehicle( )->display_attributes( ).
{% endhighlight %}

* **Factory Methods**
    * Public static method that creates an instance of the class and returns the reference of this instance to the caller are known as factory methods.
    * Factory methods are executed when an instance of the class is created and has following advantages as compared to the instance constructor.
        * A factory method can have coding that executes before the actual instantiation. eg: the method can perform checks, read data from the database or set locks before actually creating the instance. If an error occurs, no instance is created and no memory is allocated for it.
        * Classes can have more than one factory method. Each of the methods can have a different implementation and signature as well. The different factory method makes it possible to create instances of the same class based on different information. eg: one factory method creates a new instance that offers input parameters for all attributes, while another factory method only imports key information and then retrieve the other attribute values from the database.
        * Use factory methods to administrate the instances of a class within the class itself. The administration of the instance within the class is often used to avoid the creation of many identical instances. A reference of every new instance is stored in a private static attribute of the class (an internal table). Whenever the factory method is called, it first checks whether an instance with this key already exists. If so, it returns the exisiting instance instead of creating a new one.
        * Use a factory method to instantiate one of the subclasses rather than the class itself. eg: the factory method of an airplane class can check the plane type and then instantiate either a cargo or a passenger plane.

* **Singleton Pattern**
    * Singleton concept is used to prevent a class from being instantiated more than once.
    * There are different way to implement the singleton pattern.
        * First pattern is special case of the factory concept. Instead of storing several instances, the class stores only one instance. When the factory method `get_instance( )` is called for the first time, it instantiates the class. For every subsequent call, it returns the reference to the exisiting object.
        * Second pattern is using static constructor to create the single instance in advance. The `get_instance( )` method does not create the instance but only returns a reference to the already exisiting instance.
        * Third pattern is the `go_instance` static attribute is made public and read-only. The `get_instance( )` method is not required.

Singleton pattern using factory method

{% highlight javascript %}
    "1. Restrict the visibility of the instance constructor and inhibit any inheritance from the class."
    CLASS lcl_singleton DEFINITION CREATE PRIVATE FINAL.
        
        PUBLIC SECTION.
            <<code>>
            "3. Define a get_isntance method"
            CLASS-METHODS get_instance RETURNING VALUE(ro_instance) TYPE REF TO lcl_singleton.
            <<code>>
        
        PRIVATE SECTION.
            "2. Define a static attribute to store a reference to the one instance there."
            CLASS-DATA go_instance TYPE REF TO lcl_singleton.

    ENDCLASS.

    CLASS lcl_singleton IMPLEMENTATION.
        "4. Implement the get_instance method to instantiate the class"
        METHOD get_instance.
            IF go_instance IS NOT BOUND.
                go_instance = NEW lcl_singleton( ).
            ENDIF

            ro_instance = go_instance.
        ENDMETHOD.

    ENDCLASS.

    "5. Retrieve the instance using get_instance method"
    DATA(go_singleton) = lcl_singleton=>get_instance( ).
    "6. call respective methods using the go_singleton object." 
    go_singleton->(methods from singleton class)

{% endhighlight %}

Singleton pattern using static constructor

{% highlight javascript %}
    CLASS lcl_singleton DEFINITION CREATE PRIVATE FINAL.
        
        PUBLIC SECTION.
            <<code>>
            CLASS-METHODS get_instance RETURNING VALUE(ro_instance) TYPE REF TO lcl_singleton.
            CLASS-METHODS class_constructor.
            <<code>>
        
        PRIVATE SECTION.
            CLASS-DATA go_instance TYPE REF TO lcl_singleton.

    ENDCLASS.

    CLASS lcl_singleton IMPLEMENTATION.

        METHOD class_constructor.
            IF go_instance IS NOT BOUND.
                go_instance  = NEW lcl_singleton( ).
            ENDIF.
        ENDCLASS.

        METHOD get_instance.
            ro_instance = go_instance.
        ENDMETHOD.
        
    ENDCLASS.
{% endhighlight %}

* **Friends Concept**
    * A class can grant friendship to other classes and interfaces and hence to all classes that implment the interface.
    * To create frienship, use `FRIENDS` addition of the `CLASS` statement.
    * A class granting friendship is not automatically a friend of the classes friends. 
    * If a class granting friendship wants to access the non-public components of a friend, this friend must also explicitly grant friendship to it.

* **Implementation of Factory Classes**
    * A trypical application of the friends concept is the definition of a factory class.
    * Like the factory method, a factory class creates and administrates the instances of a class.
    * By outsourcing the administration to a dedicated class, the class itself is kept smaller and easier to understand.
    * eg: `LCL_FACTORY` serves as a factory class for airplanes.
    * `LCL_FACTORY` class provides a public method `CREATE_AIRPLANE( )` in which `CREATE_AIRPLANE( )` either instantiates class `LCL_AIRPLANE` or returns a reference to an already exisiting instance.
    * To restrict the instantiation, class `LCL_AIRPLANE` is defined with addition `CREATE_PRIVATE`.
    * By adding `FRIENDS lcl_factory`, the friendship allows the factory class and only the factory class to create airplane instances and to access the private attributes.
    * Another advantage of the dedicated factory class is that if the class has subclasses, the decision on which of the classes should be instantiated could be done inside the factory class rather than by the calling program.
    * eg: the `CREATE_AIRPLANE( )` method could create and return an instance of either `LCL_CARGO_PLANE` or `LCL_PASSENGER_PLANE` depending on the planetype.

* **Friendship and Inheritance**
    * The friend attribute is inherited.
    * Classes that inherit from friends and interfaces containing a friend as a component interface, also become friends.
    * Note, take precaution when granting friendship. The higher up a friend is in the inheritance tree, the more subclasses can access all components of a class that grants friendship.
    * Conversly granting friendship is not inherited. A friend of a superclass is, therefore not automatically a friend of its subclasses.

{% highlight javascript %}
    CLASS lcl_factory DEFINITION.
        
        PUBLIC SECTION.
            <<code>>
            CLASS-METHODS create_airplane RETURNING VALUE(ro_instance) TYPE REF TO lcl_airplane.
            <<code>>

    ENDCLASS.

    CLASS lcl_factory IMPLEMENTATION.

        METHOD create_airplane.
            IF lcl_airplane=>go_airplane IS NOT BOUND.
                lcl_airplane=>go_airplane = NEW lcl_airplane( ).
            ENDIF.

            ro_instance = lcl_airplane=>go_airplane.
        ENDCLASS.
        
    ENDCLASS.

    CLASS lcl_airplane DEFINITION CREATE PRIVATE FRIENDS lcl_factory.

        PRIVATE SECTION.
            CLASS-DATA go_airplane TYPE REF TO lcl_airplane.

    ENDCLASS.
{% endhighlight %}